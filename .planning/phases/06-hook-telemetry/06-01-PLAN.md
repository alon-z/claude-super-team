---
phase: 06-hook-telemetry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plugins/claude-super-team/scripts/telemetry.sh
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "telemetry.sh captures skill_start, skill_end, agent_spawn, agent_complete, tool_use, and tool_failure events as JSONL lines"
    - "telemetry.sh silently exits 0 when .planning/ directory does not exist"
    - "telemetry.sh auto-creates .planning/.telemetry/ if .planning/ exists"
    - "telemetry.sh uses TELEMETRY_FILE env var when available, otherwise generates a deterministic fallback path"
    - "On skill_start events, telemetry.sh persists TELEMETRY_FILE to CLAUDE_ENV_FILE so subsequent hooks in the same session write to the same JSONL file"
    - ".planning/.telemetry/ is gitignored"
  artifacts:
    - path: "plugins/claude-super-team/scripts/telemetry.sh"
      provides: "Shared telemetry capture script called by skill hooks"
    - path: ".gitignore"
      provides: "Updated gitignore with .telemetry/ exclusion"
  key_links:
    - from: "plugins/claude-super-team/scripts/telemetry.sh"
      to: ".planning/.telemetry/*.jsonl"
      via: "File append writes JSONL to telemetry directory"
---

<objective>
Create the shared `telemetry.sh` shell script and add `.planning/.telemetry/` to `.gitignore`.

Purpose: This script is the single telemetry capture engine called by all orchestrator skill hooks. It reads hook JSON from stdin, extracts relevant fields, and appends a JSONL line to a session-scoped file. It must be completely fail-safe -- telemetry must never disrupt skill execution.

Output: `plugins/claude-super-team/scripts/telemetry.sh` (executable), updated `.gitignore`
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-hook-telemetry/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create telemetry.sh shell script</name>
  <files>plugins/claude-super-team/scripts/telemetry.sh</files>
  <action>
Create `plugins/claude-super-team/scripts/telemetry.sh` with the following implementation:

**Header and options:**
- Shebang: `#!/usr/bin/env bash`
- Comment block: script purpose, usage (`telemetry.sh <event_type> <skill_name>`), event types list
- `set -uo pipefail`

**Arguments:**
- `EVENT_TYPE="${1:-unknown}"` -- first argument: skill_start, skill_end, agent_spawn, agent_complete, tool_use, tool_failure
- `SKILL_NAME="${2:-unknown}"` -- second argument: execute-phase, plan-phase, research-phase, brainstorm

**Directory resolution and no-op guard:**
- `PROJECT_DIR="${CLAUDE_PROJECT_DIR:-.}"`
- `TELEMETRY_DIR="${PROJECT_DIR}/.planning/.telemetry"`
- Check `[ -d "${PROJECT_DIR}/.planning" ] || exit 0` -- graceful no-op if .planning/ missing
- `mkdir -p "${TELEMETRY_DIR}" 2>/dev/null || exit 0` -- auto-create, silent fail

**jq availability check:**
- Check if `jq` is available: `command -v jq >/dev/null 2>&1`
- Set a flag `HAS_JQ=true/false`
- If jq is NOT available, define a fallback function `_json_val` that extracts a value from JSON using grep/sed:
  ```bash
  _json_val() {
    echo "$1" | grep -o "\"$2\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | head -1 | sed 's/.*:[[:space:]]*"\([^"]*\)".*/\1/'
  }
  ```

**Read stdin:**
- `INPUT=$(cat)` -- reads the hook JSON payload from stdin

**Extract common fields:**
- If `HAS_JQ=true`: `SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // "unknown"' 2>/dev/null || echo "unknown")`
- If `HAS_JQ=false`: `SESSION_ID=$(_json_val "$INPUT" "session_id")` with fallback to "unknown" if empty
- `TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")`

**Determine output file path:**
- If `TELEMETRY_FILE` env var is set and non-empty, use it: `OUTFILE="${TELEMETRY_FILE}"`
- Otherwise, generate a deterministic path: `DATE_SLUG=$(date -u +"%Y-%m-%dT%H-%M-%S")` and `OUTFILE="${TELEMETRY_DIR}/${SKILL_NAME}-${DATE_SLUG}.jsonl"`

**Persist TELEMETRY_FILE for session (skill_start only):**
When `EVENT_TYPE` is `skill_start`, the hook is a SessionStart hook which has access to `CLAUDE_ENV_FILE`. After determining `OUTFILE`, if `CLAUDE_ENV_FILE` is set and the `TELEMETRY_FILE` env var was NOT already set, write `export TELEMETRY_FILE="${OUTFILE}"` to `$CLAUDE_ENV_FILE`. This ensures all subsequent hooks in the same session (Stop, SubagentStart, PostToolUse, etc.) inherit the `TELEMETRY_FILE` env var and write to the same file.

```bash
if [ "${EVENT_TYPE}" = "skill_start" ] && [ -n "${CLAUDE_ENV_FILE:-}" ] && [ -z "${TELEMETRY_FILE:-}" ]; then
  echo "export TELEMETRY_FILE=\"${OUTFILE}\"" >> "${CLAUDE_ENV_FILE}" 2>/dev/null
fi
```

Place this block AFTER determining `OUTFILE` and BEFORE the case statement that builds event-specific data.

**Build event-specific data (case statement):**
Use `jq -c` when available, fall back to `_json_val` or `'{}'` when not.

- `skill_start`: Extract `{source: .source, model: .model}` from input. These come from the SessionStart hook's JSON payload.
- `skill_end`: Extract `{reason: .reason}` from input. Comes from Stop hook.
- `agent_spawn`: Extract `{agent_type: .agent_type, agent_id: .agent_id}` from input.
- `agent_complete`: Extract `{agent_type: .agent_type, agent_id: .agent_id, transcript_path: .agent_transcript_path}` from input.
- `tool_use`: Extract `{tool_name: .tool_name}` from input. Do NOT capture tool_input (can be very large).
- `tool_failure`: Extract `{tool_name: .tool_name, error: (.error // "unknown") | .[0:200]}` from input. Truncate error to 200 chars.
- Default (`*`): `DATA='{}'`

**Write JSONL line:**
```bash
echo "{\"event\":\"${EVENT_TYPE}\",\"skill\":\"${SKILL_NAME}\",\"session_id\":\"${SESSION_ID}\",\"timestamp\":\"${TIMESTAMP}\",\"data\":${DATA}}" >> "${OUTFILE}" 2>/dev/null
```

**Exit:**
- Always `exit 0` -- never disrupt the hook flow.

**Important constraints:**
- NEVER write to stdout. Hook stdout gets injected into Claude's context, wasting tokens. All output goes to the JSONL file only.
- NEVER exit non-zero. The script is passive telemetry.
- Keep each JSONL line under 4KB (OS pipe buffer size) to avoid corruption from concurrent async hook writes.
- Use 2-space indentation (matching project convention from progress-gather.sh).

Make the file executable: `chmod +x plugins/claude-super-team/scripts/telemetry.sh`
  </action>
  <verify>
1. `bash -n plugins/claude-super-team/scripts/telemetry.sh` -- syntax check passes (exit 0)
2. `test -x plugins/claude-super-team/scripts/telemetry.sh` -- file is executable
3. Test no-op behavior: `echo '{}' | bash plugins/claude-super-team/scripts/telemetry.sh skill_start test-skill` exits 0 and produces no stdout (will no-op because .planning/ likely does not exist in the plugin dir)
4. Verify the script contains: `set -uo pipefail`, `exit 0` at the end, no `echo` statements that write to stdout (only to files via `>>`)
  </verify>
  <done>telemetry.sh exists at plugins/claude-super-team/scripts/telemetry.sh, is executable, passes bash syntax check, handles all 6 event types, persists TELEMETRY_FILE via CLAUDE_ENV_FILE on skill_start, gracefully no-ops when .planning/ is missing, never writes to stdout, and always exits 0</done>
</task>

<task type="auto">
  <name>Task 2: Add .planning/.telemetry/ to .gitignore</name>
  <files>.gitignore</files>
  <action>
Append `.planning/.telemetry/` to the existing `.gitignore` file.

The current `.gitignore` contains:
```
__pycache__/
.DS_Store
.firecrawl/
.planning/.sessions/
```

Add the new entry after `.planning/.sessions/` to keep the `.planning/` exclusions grouped together:
```
.planning/.telemetry/
```

Do not modify any existing entries.
  </action>
  <verify>
1. `grep -q '.planning/.telemetry/' .gitignore` -- entry exists (exit 0)
2. `wc -l < .gitignore` -- should be 5 lines (4 existing + 1 new)
  </verify>
  <done>.gitignore contains .planning/.telemetry/ entry, existing entries are unchanged</done>
</task>

</tasks>

<verification>
1. `ls -la plugins/claude-super-team/scripts/telemetry.sh` -- file exists and is executable
2. `bash -n plugins/claude-super-team/scripts/telemetry.sh` -- no syntax errors
3. `grep 'exit 0' plugins/claude-super-team/scripts/telemetry.sh` -- confirms fail-safe exit
4. `grep -c 'echo.*>>' plugins/claude-super-team/scripts/telemetry.sh` -- confirms writes go to file (>>), not stdout
5. `grep '.planning/.telemetry/' .gitignore` -- gitignore entry present
6. Verify no stdout leaks: `echo '{"session_id":"test"}' | bash plugins/claude-super-team/scripts/telemetry.sh skill_start test 2>/dev/null | wc -c` should output 0
</verification>

<success_criteria>
- telemetry.sh exists, is executable, passes syntax check
- Handles all 6 event types: skill_start, skill_end, agent_spawn, agent_complete, tool_use, tool_failure
- Reads hook JSON from stdin, writes JSONL to .planning/.telemetry/
- Gracefully no-ops (exit 0, no output) when .planning/ does not exist
- Auto-creates .planning/.telemetry/ when .planning/ exists
- Uses TELEMETRY_FILE env var when set, deterministic fallback when not
- On skill_start events, persists TELEMETRY_FILE via CLAUDE_ENV_FILE for session continuity
- Falls back to grep/sed when jq is unavailable
- Never writes to stdout
- .planning/.telemetry/ is in .gitignore
</success_criteria>

<output>
After completion, create `.planning/phases/06-hook-telemetry/06-01-SUMMARY.md`
</output>
