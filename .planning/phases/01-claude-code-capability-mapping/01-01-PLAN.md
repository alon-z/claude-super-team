---
phase: 01-claude-code-capability-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CAPABILITY-REFERENCE.md
autonomous: false

must_haves:
  truths:
    - "A companion reference document exists at project root alongside ORCHESTRATION-REFERENCE.md"
    - "The document covers all Claude Code capability categories: Skills, Agents, Hooks, Plugins, Tools, CLI, Settings, Memory, Session, Monitoring"
    - "Each capability has an adoption status flag: In use, Documented but unused, or Unverified"
    - "Capabilities already detailed in ORCHESTRATION-REFERENCE.md are cross-referenced, not duplicated"
    - "Changelog-sourced capabilities appear in the reference document (or an explicit note confirms the changelog contained no new findings beyond research)"
  artifacts:
    - path: "CAPABILITY-REFERENCE.md"
      provides: "Complete Claude Code capability inventory with adoption status flags and audit annotations"
  key_links:
    - from: "CAPABILITY-REFERENCE.md"
      to: "ORCHESTRATION-REFERENCE.md"
      via: "Section cross-references using '(See ORCHESTRATION-REFERENCE.md: [Section Name])' format"
---

<objective>
Create the companion capability reference document (CAPABILITY-REFERENCE.md) at the project root.

Purpose: This document serves as the audit standard for Phase 2. It inventories every Claude Code ecosystem capability, flags what this marketplace uses vs what it does not, and identifies unverified capabilities -- giving Phase 2 a complete checklist to evaluate each skill against.

Output: A single markdown file (CAPABILITY-REFERENCE.md) organized by capability category, with table-based entries showing capability name, description, adoption status, ORCHESTRATION-REFERENCE.md cross-reference, and tradeoff/when-to-use notes.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-claude-code-capability-mapping/01-CONTEXT.md
@.planning/phases/01-claude-code-capability-mapping/01-RESEARCH.md
@ORCHESTRATION-REFERENCE.md
</context>

<tasks>

<task type="checkpoint:human-verify">
  <name>Task 1: Collect Claude Code changelog from user</name>
  <files>N/A (information gathering)</files>
  <action>
Prompt the user with AskUserQuestion to paste the Claude Code changelog. The prompt should explain:
- This is Phase 1 execution: building the capability reference document
- The changelog is needed to cross-reference capabilities and catch recent additions not yet in official docs
- The user mentioned during /discuss-phase that they would provide the changelog via paste during execution
- Ask them to paste the changelog content (or the most recent/relevant portions if it is very long)

After receiving the changelog, extract all capability-relevant entries:
- New features (tools, frontmatter fields, hook events, CLI flags, environment variables)
- Behavioral changes to existing capabilities
- Deprecations or renames
- Items that appear in the changelog but NOT in the research findings (01-RESEARCH.md)

Store these extracted findings in working memory for use in Task 2.
  </action>
  <verify>User has provided changelog content and executor has identified capability-relevant entries from it.</verify>
  <done>Changelog content received and parsed. New findings (if any) extracted and ready for incorporation into the reference document.</done>
</task>

<task type="auto">
  <name>Task 2: Research gaps and determine adoption status for all capabilities</name>
  <files>N/A (research -- reads codebase files, does not modify them)</files>
  <action>
Perform two parallel research activities:

**A. Targeted web research via Firecrawl to fill remaining gaps from 01-RESEARCH.md:**

Use the Firecrawl skill (preloaded) to fetch the following official doc pages and extract specific missing details. Focus on the HIGH and MEDIUM priority gaps identified in 01-RESEARCH.md:

1. https://code.claude.com/docs/en/output-styles -- Full output style specification (frontmatter fields, keep-coding-instructions behavior, distribution via plugins)
2. https://code.claude.com/docs/en/plugins-reference -- Complete plugin manifest schema, LSP server config format, plugin caching details, CLI commands reference
3. https://code.claude.com/docs/en/checkpointing -- Checkpointing/rewind mechanics, /rewind command, Esc+Esc shortcut
4. https://code.claude.com/docs/en/skills -- Dynamic context injection syntax (!`command`), $N argument shorthand, skill description character budget, Agent Skills standard reference
5. https://code.claude.com/docs/en/hooks -- once field, statusMessage field, handler deduplication, Setup event details
6. https://code.claude.com/docs/en/memory -- Auto Memory details, CLAUDE.local.md, modular rules path frontmatter
7. https://code.claude.com/docs/en/settings -- Complete tool list (all 22), CLAUDE_BASH_MAINTAIN_PROJECT_WORKING_DIR, environment variables
8. https://code.claude.com/docs/en/keybindings -- Keybinding configuration options

For each page, extract:
- Capability name, description, configuration syntax
- Any details not already captured in 01-RESEARCH.md
- Cross-reference each finding against the changelog (from Task 1) for confirmation

**Intermediate checkpoint:** Before proceeding to the codebase scan, verify that all 8 doc pages were successfully fetched. If any page failed, note the gap and proceed -- the capability will be marked "Unverified" in the final inventory.

**B. Codebase scan to determine adoption status per capability:**

Scan all plugin skill and agent files using these glob patterns:
- `plugins/*/skills/*/SKILL.md` -- all skill definitions across all plugins
- `plugins/*/agents/*.md` -- all agent definitions across all plugins
- `plugins/*/.claude-plugin/plugin.json` -- all plugin manifests
- `.claude-plugin/marketplace.json` -- marketplace manifest
- `CLAUDE.md` -- project-level memory
- `ORCHESTRATION-REFERENCE.md` -- existing reference

For each file, extract:
- Which frontmatter fields are used and where
- Which tools are referenced in allowed-tools/disallowedTools
- Which model overrides are set
- Whether any hooks, output styles, or LSP configs exist in any plugin
- Which context modes are used (skill vs fork)
- Which environment variables are referenced in skill bodies or CLAUDE.md

**Adoption status classification logic:**

For each capability in the inventory, apply this decision tree:
1. **In use** -- the capability appears in at least one frontmatter field, config file, or skill body in the scanned codebase files above
2. **Documented but unused** -- the capability is confirmed by at least two sources (official docs + research or changelog) but does NOT appear anywhere in the codebase scan
3. **Unverified** -- the capability was found in only a single source (e.g., only in 01-RESEARCH.md training data, or only in changelog, or only in one doc page) and cannot be cross-referenced against a second source

Also incorporate any new findings from the changelog (Task 1) into the appropriate categories.
  </action>
  <verify>
- All 8 official doc pages have been fetched and parsed
- Adoption status determined for every capability in the inventory -- confirm by checking: every HIGH priority gap from 01-RESEARCH.md has an explicit "In use", "Documented but unused", or "Unverified" flag; every MEDIUM priority gap likewise has a flag
- Changelog findings incorporated -- confirm by checking: at least one changelog-exclusive capability (not already in 01-RESEARCH.md) has been added to the inventory, OR explicitly note that the changelog contained no new findings beyond what research already captured
- No capability left without a status classification
- Codebase scan covered all files matching the specified glob patterns (spot-check: count of skill files scanned matches the expected 17 skills + 1 agent)
  </verify>
  <done>Complete capability inventory with adoption status flags ready for document assembly. All gaps from 01-RESEARCH.md addressed with additional research. Changelog findings incorporated.</done>
</task>

<task type="auto">
  <name>Task 3: Assemble and write CAPABILITY-REFERENCE.md</name>
  <files>CAPABILITY-REFERENCE.md</files>
  <action>
Create CAPABILITY-REFERENCE.md at the project root with the following structure:

**Header:**
```markdown
# Claude Code Capability Reference -- Audit Companion

Companion to [ORCHESTRATION-REFERENCE.md](./ORCHESTRATION-REFERENCE.md). This document inventories all Claude Code ecosystem capabilities with adoption status flags for audit purposes. Where ORCHESTRATION-REFERENCE.md provides detailed coverage, this document cross-references rather than duplicates.

**Adoption Status Legend:**
- **In use** -- actively used in this marketplace's skills/agents/config
- **Documented but unused** -- confirmed capability not leveraged by this marketplace (Phase 2 adoption opportunity)
- **Unverified** -- found in single source only; needs empirical verification

*Generated: [date] | Claude Code version: [from changelog if available]*
```

**Sections (one per capability category):**

For each section, use a table format:
| Capability | Description | Status | ORCH-REF Section | Notes |
Where:
- Capability = name of the feature/field/flag
- Description = brief one-line explanation
- Status = In use / Documented but unused / Unverified
- ORCH-REF Section = section name in ORCHESTRATION-REFERENCE.md if covered there, or "Not covered" if it is a gap
- Notes = tradeoffs, when-to-use, or audit-specific annotations

**Section order:**

1. **Skills** -- All skill frontmatter fields (10 official), variable substitution, invocation methods, context modes, dynamic context injection, description character budget, Agent Skills standard, skill precedence
2. **Agents** -- All agent frontmatter fields (11 official), built-in agent types, tool restriction syntax, invocation methods, agent memory
3. **Hooks** -- All hook events (14-15), handler types, common fields (type, command, timeout, statusMessage, once, async), hook configuration locations, handler deduplication
4. **Plugins** -- Plugin manifest schema (complete), plugin component types (skills, agents, hooks, MCP, LSP, output styles), plugin distribution (sources, marketplaces), plugin CLI commands, plugin caching, $CLAUDE_PLUGIN_ROOT
5. **Tools** -- Complete tool list (22 tools) with permission requirements, tool naming conventions for MCP
6. **CLI Flags** -- All CLI flags organized by category (agent/model control, session, execution, system prompt, configuration), --plugin-dir for development
7. **Settings & Permissions** -- Settings precedence, permission modes, permission rule syntax, sandbox configuration
8. **Memory & Context** -- CLAUDE.md locations (project, user, managed policy, CLAUDE.local.md), modular rules (.claude/rules/ with path frontmatter), Auto Memory, imports, nested discovery, context compaction
9. **Session Management** -- Persistence, resumption, forking, remote sessions, checkpointing/rewind, named sessions
10. **Monitoring & UI** -- Status line, /cost, /context, /stats, OTEL, keybindings, fast mode
11. **Agent Teams** -- Team tools, coordination mechanics, display modes (reference ORCHESTRATION-REFERENCE.md heavily here)
12. **Environment Variables** -- Complete list of Claude Code env vars with purpose and adoption status

**Per-section de-duplication strategy (enforces Decision 2 from CONTEXT.md -- must not duplicate ORCHESTRATION-REFERENCE.md):**

For EACH capability, before writing its entry, apply this decision:
1. **Read the corresponding section in ORCHESTRATION-REFERENCE.md** for that capability
2. **If ORCHESTRATION-REFERENCE.md provides detailed coverage** (definition + examples + tradeoffs or configuration syntax): use cross-reference format only -- one table row with the capability name, a brief one-line description, adoption status flag, the ORCH-REF section name, and a note. Do NOT reproduce the detailed coverage.
3. **If ORCHESTRATION-REFERENCE.md only mentions the capability in passing** (listed in a bullet or table without elaboration): provide a medium entry -- one table row plus a 1-2 sentence note below the table with the key detail missing from ORCH-REF.
4. **If ORCHESTRATION-REFERENCE.md does not cover the capability at all** (the gaps from 01-RESEARCH.md): provide a full entry -- one table row plus a subsection or expanded note with description, syntax example if useful, and adoption opportunity notes.

This ensures zero verbatim duplication while still providing complete coverage for audit purposes.

**Additional per-section rules:**
- Clearly separate skill-only vs agent-only vs shared frontmatter fields (per 01-RESEARCH.md finding about the 10 vs 11 official field sets).

**Footer:**
- "Unverified Items" section listing all capabilities marked Unverified with the single source they came from and what would confirm them
- "Changelog Watch" section listing capability areas to re-check when Claude Code updates
- Sources section listing all official doc URLs consulted

Write the complete file. Target approximately 400-600 lines -- enough to be comprehensive but not so long it becomes unwieldy. Prefer concise table entries over prose paragraphs.
  </action>
  <verify>
- File exists at project root: `ls -la CAPABILITY-REFERENCE.md`
- File is valid markdown (no broken tables or formatting)
- Every capability from 01-RESEARCH.md gaps (HIGH and MEDIUM priority) appears in the document
- Every capability has a status flag (In use / Documented but unused / Unverified)
- Cross-references to ORCHESTRATION-REFERENCE.md use consistent format
- No content duplicated verbatim from ORCHESTRATION-REFERENCE.md
- Deferred ideas (context: fork testing, scratch skills, skill modification) do NOT appear as tasks or recommendations
  </verify>
  <done>
CAPABILITY-REFERENCE.md exists at project root with:
- All 12 capability sections populated with table entries
- Every capability flagged with adoption status
- Cross-references to ORCHESTRATION-REFERENCE.md where applicable
- Gap capabilities (from research) documented with full detail
- Unverified items listed with single-source attribution
- Changelog Watch section for future maintenance
  </done>
</task>

</tasks>

<verification>
1. `CAPABILITY-REFERENCE.md` exists at project root alongside `ORCHESTRATION-REFERENCE.md`
2. The document covers all 12 capability categories listed in the plan
3. Every HIGH and MEDIUM priority gap from 01-RESEARCH.md has a corresponding entry
4. The three adoption status flags are used consistently throughout
5. No verbatim duplication of ORCHESTRATION-REFERENCE.md content
6. Changelog content from user has been incorporated
7. Unverified items are explicitly listed in the footer section
</verification>

<success_criteria>
Phase 1 success criteria are met:
1. A capability reference document exists covering all skill frontmatter fields, agent definition syntax, hooks, and context behavior options
2. Each capability is documented with when to use it and tradeoffs, with adoption status flags for audit purposes
3. The reference is accurate against the current Claude Code version (verified by cross-referencing official docs, codebase usage, and user-provided changelog)
</success_criteria>

<output>
After completion, create `.planning/phases/01-claude-code-capability-mapping/01-01-SUMMARY.md` documenting:
- What was created (CAPABILITY-REFERENCE.md)
- Capability counts per category and per adoption status
- Key findings: most impactful unused capabilities, unverified items requiring Phase 2 attention
- Any changelog discoveries not in the original research
</output>
